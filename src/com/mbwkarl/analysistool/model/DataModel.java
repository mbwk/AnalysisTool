/*
 * Copyright 2015 Karl Birch.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mbwkarl.analysistool.model;

import com.mbwkarl.analysistool.utils.StreamDataType;
import com.mbwkarl.analysistool.utils.LogReader;
import com.mbwkarl.analysistool.utils.UserInterfaceNotifier;
import com.mbwkarl.analysistool.utils.XlogIO;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Karl Birch
 */
public class DataModel {
    
    // tools
    private ArrayList<UserInterfaceNotifier> notifiers = new ArrayList<>();
    
    // modelled data
    private DataLogContainer dataLogContainer = new DataLogContainer();
    private ArrayList<DataStream> dataStreams = new ArrayList<>();
    
    public DataModel() {
        // ctor
    }
    
    public void addNotifier(UserInterfaceNotifier notifier) {
        notifiers.add(notifier);
    }
    
    private void reloadDataStreams() {
        dataStreams = new ArrayList<>();
    }
    
    /**
     * Gets the IDs of all streamable formats (i.e. contains at least one
     * attribute with the "TIME" data type.
     * @return ArrayList of Strings containing the IDs.
     */
    public ArrayList<String> getStreamableFormats() {
        ArrayList<String> typesList = dataLogContainer.getTypesList();
        ArrayList<String> streamableTypes = new ArrayList<>();
        for (String s : typesList) {
            FormatMap fm = dataLogContainer.fmtlookup(s);
            
            // skip formats with no entries
            if (dataLogContainer.getEntryCountFor(fm) == 0) {
                continue;
            }
            int limit = fm.getAttributeCount();
            for (int i = 0; i < limit; ++i) {
                if (fm.getTypeOf(i) == StreamDataType.TIME) {
                    streamableTypes.add(fm.getID());
                    break;
                }
            }
        }
        return streamableTypes;
    }
    
    // <editor-fold desc="Datalog Creation/Loading">
    private DataLogContainer readFromLogFile(File file) {
        DataLogContainer datalog = new DataLogContainer();
        
        LogReader reader = new LogReader(file);
        datalog.addEntry("Generated by AnalysisTool");
        
        while (!reader.isFinished()) {
            ArrayList<String> fragments = reader.parseLine();
            datalog.addEntry(fragments);
        }
        datalog.addEntry("Corruptions: " + datalog.getCorruptionCount());
        
        return datalog;
    }
    
    private DataLogContainer readFromXmlFile(File file) {
        DataLogContainer datalog;
        
        XlogIO xio = new XlogIO();
        datalog = xio.deserializeXmlFile(file);
        
        return datalog;
    }
    
    private boolean isXmlFile(File file) {
        boolean isxmlfile = false;
        
        try {
            BufferedReader ifstream = new BufferedReader(new FileReader(file));
            String firstline = ifstream.readLine();
            isxmlfile = firstline.contains("<?xml");
            ifstream.close();
        } catch (IOException ex) {
            Logger.getLogger(DataModel.class.getName()).log(Level.SEVERE, null, ex);
            isxmlfile = false;
        } finally {
            return isxmlfile;
        }
    }
    
    private DataLogContainer deduceFile(File file) {
        if (file.exists()) {
            if (isXmlFile(file)) {
                System.err.println("XML file detected");
                return readFromXmlFile(file);
            } else {
                System.err.println("Non-XML file detected");
                return readFromLogFile(file);
            }
        } else {
            return null;
        }
    }
    // </editor-fold>
    
    public void loadFromFile(File file) {
        setDataLog(deduceFile(file));
        //notifiers.stream().forEach((notif) -> {
        for (UserInterfaceNotifier notif : notifiers) {
            if (dataLogContainer == null) {
                notif.failedLoadFile(file.getName());
            } else {
                reloadDataStreams();
                notif.loadedFile(file.getName());
                notif.broadcastEntryCount(dataLogContainer.getEntryCount());
                notif.broadcastFormats(getStreamableFormats());
                notif.broadcastDataStreams(dataStreams);
                notif.broadcastCorruptions(dataLogContainer.getCorruptionCount());
            }
        }
        //});
    }
    
    public void writeToFile(java.io.File file) {
        XlogIO xio = new XlogIO();
        boolean saved = xio.serializeXmlFile(file, dataLogContainer);
        
        //notifiers.stream().forEach((notif) -> {
        for (UserInterfaceNotifier notif : notifiers) {
            if (saved) {
                notif.savedFile(file.getName());
            } else {
                notif.failedSaveFile(file.getName());
            }
        }
        //});
    }
    
    private void setDataLog(DataLogContainer container) {
        dataLogContainer = container;
    }
    
    protected void pollProperty(ModelProperty property) {
        if (dataLogContainer == null) {
            for (UserInterfaceNotifier notifier : notifiers) {
                notifier.mustLoadFile();
            }
        } else {
            selectProperty(property);
        }
    }
    
    private String[] proplist = {
        " [l] - list",
        "[ec] - entry-count",
        " [f] - formats"
    };
    
    private void selectProperty(ModelProperty property) {
        for (UserInterfaceNotifier notifier : notifiers) {
            switch (property) {
                case LIST:
                    notifier.broadcastPropertyList(proplist);
                    break;
                    
                case ENTRY_COUNT:
                    notifier.broadcastEntryCount(dataLogContainer.getEntryCount());
                    break;
                    
                case FORMATS:
                    notifier.broadcastFormats(dataLogContainer.getTypesList());
                    break;
                    
                case UNKNOWN:
                    System.err.println("Unknown property");
                    break;
                    
                default:
                    System.err.println("Unhandled property: ");
                    System.err.println(property.toString());
                    break;
            }
        }
        
    }

    protected void requestFormatAttributes(String formatID) {
        FormatMap fm = dataLogContainer.fmtlookup(formatID);
        if (fm == null) {
            return;
        }
        
        ArrayList<EntryAttribute> xAttrList = fm.getFilteredCopyOfAttributes(StreamDataType.TIME);
        ArrayList<EntryAttribute> yAttrList = fm.getFilteredCopyOfAttributes(StreamDataType.BIGDECIMAL, StreamDataType.BIGINTEGER, StreamDataType.LATLON);
        for (UserInterfaceNotifier notif : notifiers) {
            notif.broadcastFormatMap(formatID, xAttrList, yAttrList);
        }
    }
    
    protected void requestDataStreamExtraction(String streamName,
                    String xAxisName, String yAxisName,
                    String formatType, String keyAttr, String valAttr) { 
        FormatMap formatMap = dataLogContainer.fmtlookup(formatType);
        if (formatMap == null) {
            return;
        }
        DataStream newStream = dataLogContainer.extractDataStream(streamName,
                xAxisName, yAxisName, formatMap, keyAttr, valAttr);
        if (newStream != null) {
            dataStreams.add(newStream);
            notifyOfDatastreams();
        }
    }
    
    public void notifyOfDatastreams() {
        //notifiers.stream().forEach((notif) -> {
        for (UserInterfaceNotifier notif : notifiers) {
            notif.broadcastDataStreams(dataStreams);
        }
        //});
    }
    
}
